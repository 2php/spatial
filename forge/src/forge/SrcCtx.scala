package forge

import scala.reflect.macros.blackbox.Context
import scala.language.experimental.macros

import scala.collection.mutable

case class SrcCtx(dir: String, file: String, line: Int, column: Int, content: Option[String]) {
  override def toString = s"$file:$line:$column"
}
object SrcCtx {
  lazy val empty = SrcCtx("?", "?", 0, 0, None)

  implicit def _sc: SrcCtx = macro SourceContextMacro.impl

}


//using the available information from the macro Context, rebuild the SourceContext previously generated by the compiler
private object SourceContextMacro {

  // HACK: Mantain a hashmap for the number of times we've seen a specific tight string and the number of operands in that string
  // This is pants-on-head stupid and needs to be replaced with a simple lookup once that's available
  var visits = mutable.HashMap[String, Int]()
  var depths = mutable.HashMap[String, Int]()

  def impl(c: Context): c.Expr[SrcCtx] = {
    import c.universe._
    val pos = c.enclosingPosition
    val path = pos.source.path
    val filename = pos.source.file.name
    val line = pos.line
    val column = pos.column

    val owner = c.internal.enclosingOwner
    val assignedVariable = if (!owner.isMethod && owner.isTerm) Some(owner.name.toString) else None

    val lineContent = if (line > 0) Some(pos.source.lineToString(line-1)) else None

    def isBreak(x: Char) = x == ' ' || x == '.' || x == '(' || x == ')' || x == ';'

    // HACK: Haven't yet found a simpler way of determining which method call this is in reference to
    // Macros have a lot of support for enclosing context, but apparently very little for immediate context of implicit call
    // However, we can easily get the source line and general method call location using the column number
    // We can then reparse the immediate area (stopping at parentheses, spaces, periods, semicolons) to get the method
    // Also include try-catch blocks for now just in case we somehow mess up when splicing the string

    // TODO: pos.source.lineToString occasionally doesn't match up with the given column?
    val methodName = if (line > 0 && column > 0) {
      try {
        val str = pos.source.lineToString(line-1)

        var start = column-1
        var end = column-1
        if (isBreak(str(column-1))) start -= 1

        while (start >= 0 && !isBreak(str(start))) start -= 1
        while (end < str.length && !isBreak(str(end))) end += 1
        if (start < 0 || isBreak(str(start))) start = start + 1
        if (end >= str.length || isBreak(str(end))) end = end - 1
        val tight = str.slice(start, end+1).trim

        // The scala compiler MUST have had this information at some point to give us the correct column,
        // but it seems there's no way to get it?
        val tightTree = c.parse(tight)
        // c.info(c.enclosingPosition, "Tight: " + tight, true)
        // c.info(c.enclosingPosition, showRaw(tightTree), true)

        def extractMethod(tree: Tree, depth: Int = 0): String = tree match {
          case Select(term,func) => func.decodedName.toString //tight.replace(name,"")
          case Apply(Select(term,func), _) if depth == 0 => func.decodedName.toString
          case Apply(Select(term,func), _) => extractMethod(term, depth-1)
          case _ => tight
        }
        /**
        Given a call val x = a+b-c

        We see something for a+b-c that looks like:
              Apply(
                Select(
                  Apply(
                    Select(a, TermName(+)),
                    List(b)
                  ),
                  TermName(-)
                ),
                List(c)
              )

          Essentially means the operators are in a reversed linked list,
          so we need to know depth of list (number of times we'll see this string)
          and we need to count the number of times we've seen this same string so far
          **/
        def getMethodDepth(tree: Tree, depth: Int = 0): Int = tree match {
          case Select(term,func) => depth+1
          case Apply(Select(term,func), _) => getMethodDepth(term, depth+1)
          case _ => depth
        }

        val depth = depths.getOrElseUpdate(tight, getMethodDepth(tightTree) - 1)
        val visit = visits.getOrElse(tight, 0)
        visits += tight -> (visit + 1)

        extractMethod(tightTree, depth-visit) // Go to the last operator for the first, and so on
      }
      catch {case e:Throwable =>
        "<unknown>"
      }
    }
    else {
      "<unknown>"
    }

    // macroApplication doesn't have what we need here (it just gives a pointer to the def _sc line above)
    //val methodName = "<unknown>" //c.macroApplication.symbol.name.toString //c.internal.enclosingOwner.name.toString

    // enclosingDef is deprecated (and also gives a completely wrong answer)
    //val assignedVariable = Some(c.enclosingDef.name.toString)
    c.Expr(q"forge.SrcCtx($path, $filename, $line, $column, $lineContent)")
  }
}

